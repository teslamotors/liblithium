from lithium._lithium import ffi, lib

_sig_cdecl = "unsigned char[LITH_SIGN_LEN]"
_secret_key_cdecl = "unsigned char[LITH_SIGN_SECRET_KEY_LEN]"
_public_key_cdecl = "unsigned char[LITH_SIGN_PUBLIC_KEY_LEN]"
_prehash_cdecl = "unsigned char[LITH_SIGN_PREHASH_LEN]"


class Sign:
    """
    An object for computing or verifying a lithium signature.
    """

    def __init__(self):
        self._sign_state = ffi.new("lith_sign_state *")
        lib.lith_sign_init(self._sign_state)

    def update(self, data):
        """
        Feed new data to the signature computation.
        """
        buf = ffi.from_buffer(bytes(data))
        lib.lith_sign_update(self._sign_state, buf, len(buf))

    def final_create(self, secret_key):
        """
        Create a signature over the data given to update.
        """
        sk_buf = ffi.from_buffer(_secret_key_cdecl, bytes(secret_key))
        sig_buf = ffi.new(_sig_cdecl)
        lib.lith_sign_final_create(self._sign_state, sig_buf, sk_buf)
        return bytes(sig_buf)

    def final_verify(self, sig, public_key):
        """
        Verify a signature over the data given to update.
        """
        sig_buf = ffi.from_buffer(_sig_cdecl, bytes(sig))
        pk_buf = ffi.from_buffer(_public_key_cdecl, bytes(public_key))
        return lib.lith_sign_final_verify(self._sign_state, sig_buf, pk_buf)

    def final_prehash(self):
        """
        Compute a prehash blob from the data given to update, to be signed or verified separately.
        """
        prehash_buf = ffi.new(_prehash_cdecl)
        lib.lith_sign_final_prehash(self._sign_state, prehash_buf)
        return bytes(prehash_buf)


def keygen():
    """
    Generate a public and secret keypair.
    """
    pk_buf = ffi.new(_public_key_cdecl)
    sk_buf = ffi.new(_secret_key_cdecl)
    lib.lith_sign_keygen(pk_buf, sk_buf)
    return (bytes(pk_buf), bytes(sk_buf))


def create_from_prehash(prehash, secret_key):
    """
    Create a signature from a prehash blob generated by Sign.final_prehash.
    """
    sk_buf = ffi.from_buffer(_secret_key_cdecl, bytes(secret_key))
    prehash_buf = ffi.from_buffer(_prehash_cdecl, bytes(prehash))
    sig_buf = ffi.new(_sig_cdecl)
    lib.lith_sign_create_from_prehash(sig_buf, prehash_buf, sk_buf)
    return bytes(sig_buf)


def verify_prehash(sig, prehash, public_key):
    """
    Verify a signature on a prehash blob generated by Sign.final_prehash.
    """
    sig_buf = ffi.from_buffer(_sig_cdecl, bytes(sig))
    prehash_buf = ffi.from_buffer(_prehash_cdecl, bytes(prehash))
    pk_buf = ffi.from_buffer(_public_key_cdecl, bytes(public_key))
    return lib.lith_sign_verify_prehash(sig_buf, prehash_buf, pk_buf)


def create(data, secret_key):
    """
    Create a signature over data.
    """
    s = Sign()
    s.update(data)
    return s.final_create(secret_key)


def verify(data, sig, public_key):
    """
    Verify a signature over data.
    """
    s = Sign()
    s.update(data)
    return s.final_verify(sig, public_key)

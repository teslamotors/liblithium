// Part of liblithium, under the Apache License v2.0.
// SPDX-License-Identifier: Apache-2.0

use std::mem::MaybeUninit;

use crate::bindings::{
    lith_sign_create_from_prehash, lith_sign_final_create, lith_sign_final_prehash,
    lith_sign_final_verify, lith_sign_init, lith_sign_keygen, lith_sign_state, lith_sign_update,
    lith_sign_verify_prehash, LITH_SIGN_LEN, LITH_SIGN_PREHASH_LEN, LITH_SIGN_PUBLIC_KEY_LEN,
    LITH_SIGN_SECRET_KEY_LEN,
};

/// An object for computing or verifying a lithium signature.
#[repr(transparent)]
pub struct Sign {
    state: lith_sign_state,
}

pub const SECRET_KEY_LEN: usize = LITH_SIGN_SECRET_KEY_LEN as usize;
pub const SIGN_LEN: usize = LITH_SIGN_LEN as usize;
pub const PUBLIC_KEY_LEN: usize = LITH_SIGN_PUBLIC_KEY_LEN as usize;
pub const PREHASH_LEN: usize = LITH_SIGN_PREHASH_LEN as usize;

impl Sign {
    pub fn new() -> Sign {
        let mut s = MaybeUninit::<Sign>::uninit();
        unsafe {
            lith_sign_init(&raw mut (*s.as_mut_ptr()).state);
            s.assume_init()
        }
    }

    pub fn update(&mut self, data: &[u8]) {
        unsafe {
            lith_sign_update(&mut self.state, data.as_ptr(), data.len());
        }
    }

    pub fn final_create(&mut self, secret_key: &[u8; SECRET_KEY_LEN]) -> [u8; SIGN_LEN] {
        let mut sig = MaybeUninit::<[u8; SIGN_LEN]>::uninit();
        unsafe {
            lith_sign_final_create(
                &mut self.state,
                &raw mut (*sig.as_mut_ptr())[0],
                secret_key.as_ptr(),
            );
            sig.assume_init()
        }
    }

    pub fn final_verify(mut self, sig: &[u8; SIGN_LEN], public_key: &[u8; PUBLIC_KEY_LEN]) -> bool {
        unsafe { lith_sign_final_verify(&mut self.state, sig.as_ptr(), public_key.as_ptr()) }
    }

    pub fn final_prehash(mut self) -> [u8; PREHASH_LEN] {
        let mut prehash = MaybeUninit::<[u8; PREHASH_LEN]>::uninit();
        unsafe {
            lith_sign_final_prehash(&mut self.state, &raw mut (*prehash.as_mut_ptr())[0]);
            prehash.assume_init()
        }
    }
}

impl Default for Sign {
    fn default() -> Self {
        Self::new()
    }
}

/// Generate a public and secret keypair.
pub fn keygen() -> ([u8; PUBLIC_KEY_LEN], [u8; SECRET_KEY_LEN]) {
    let mut pk = MaybeUninit::<[u8; PUBLIC_KEY_LEN]>::uninit();
    let mut sk = MaybeUninit::<[u8; SECRET_KEY_LEN]>::uninit();
    unsafe {
        lith_sign_keygen(
            &raw mut (*pk.as_mut_ptr())[0],
            &raw mut (*sk.as_mut_ptr())[0],
        );
        (pk.assume_init(), sk.assume_init())
    }
}

/// Create a signature from a prehash blob generated by `Sign::final_prehash`.
pub fn create_from_prehash(
    prehash: &[u8; PREHASH_LEN],
    secret_key: &[u8; SECRET_KEY_LEN],
) -> [u8; SIGN_LEN] {
    let mut sig = MaybeUninit::<[u8; SIGN_LEN]>::uninit();
    unsafe {
        lith_sign_create_from_prehash(
            &raw mut (*sig.as_mut_ptr())[0],
            prehash.as_ptr(),
            secret_key.as_ptr(),
        );
        sig.assume_init()
    }
}

/// Verify a signature on a prehash blob generated by `Sign::final_prehash`.
pub fn verify_prehash(
    sig: &[u8; SIGN_LEN],
    prehash: &[u8; PREHASH_LEN],
    public_key: &[u8; PUBLIC_KEY_LEN],
) -> bool {
    unsafe { lith_sign_verify_prehash(sig.as_ptr(), prehash.as_ptr(), public_key.as_ptr()) }
}

/// Create a signature over data.
pub fn create(data: &[u8], secret_key: &[u8; SECRET_KEY_LEN]) -> [u8; SIGN_LEN] {
    let mut s = Sign::new();
    s.update(data);
    s.final_create(secret_key)
}

/// Verify a signature over data.
pub fn verify(data: &[u8], sig: &[u8; SIGN_LEN], public_key: &[u8; PUBLIC_KEY_LEN]) -> bool {
    let mut s = Sign::new();
    s.update(data);
    s.final_verify(sig, public_key)
}

#[cfg(test)]
mod test {
    use super::{create, create_from_prehash, keygen, verify, verify_prehash, Sign};

    #[test]
    fn test_sign() {
        let (pk, sk) = keygen();
        let mut data = vec![1, 2, 3];
        let sig = create(data.as_slice(), &sk);
        assert!(verify(data.as_slice(), &sig, &pk));
        data[0] ^= 0xFF;
        assert!(!verify(data.as_slice(), &sig, &pk));
    }

    #[test]
    fn test_sign_prehash() {
        let (pk, sk) = keygen();
        let data = vec![1, 2, 3];
        let mut s = Sign::new();
        s.update(data.as_slice());
        let mut prehash = s.final_prehash();
        let sig = create_from_prehash(&prehash, &sk);
        assert!(verify_prehash(&sig, &prehash, &pk));
        prehash[0] ^= 0xFF;
        assert!(!verify_prehash(&sig, &prehash, &pk));
    }
}
